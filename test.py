#!usr/bin/env python 3

# GCD
# def gcd(a,b):
#     if(a%b == 0):
#        return b
#     else:
#        return gcd(b,a%b)
    
# print(gcd(66528,52920))    


###############################
#extended euclidean
def p_q(a,b):
    # Base Case
    if a == 0:
        return b, 0, 1
    gcd, x1, y1 = p_q(b % a, a)
    x = y1 - (b//a) * x1
    y = x1
    return gcd, x, y


# a, b = 26513, 32321
# g, x, y = p_q(a, b)
# print(x,y)

###############################

# def modpower(x, n, m):
#     if n == 0: # base case
#         return 1 % m
#     u = modpower(x, n // 2, m)
#     u = (u * u) % m
#     if n % 2 == 1: # when 'n' is odd
#         u = (u * x) % m
#     return u

# print(modpower(273246787654,65536,65537))

###################################

# Quadratic residues


# k = 29
# ints = [14, 6, 11] 

# def q_res(n):
#     for i in range(1,29):
#         if (i*i) % 29 == n :
#             return i,True
#     return 0,False

# for i in ints:
#     Val,ball = q_res(i)
#     if ball == True:
#         print(Val)

####################################

# Legendre symbol

# p = 101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139

# ints = [25081841204695904475894082974192007718642931811040324543182130088804239047149283334700530600468528298920930150221871666297194395061462592781551275161695411167049544771049769000895119729307495913024360169904315078028798025169985966732789207320203861858234048872508633514498384390497048416012928086480326832803, 45471765180330439060504647480621449634904192839383897212809808339619841633826534856109999027962620381874878086991125854247108359699799913776917227058286090426484548349388138935504299609200377899052716663351188664096302672712078508601311725863678223874157861163196340391008634419348573975841578359355931590555, 17364140182001694956465593533200623738590196990236340894554145562517924989208719245429557645254953527658049246737589538280332010533027062477684237933221198639948938784244510469138826808187365678322547992099715229218615475923754896960363138890331502811292427146595752813297603265829581292183917027983351121325, 14388109104985808487337749876058284426747816961971581447380608277949200244660381570568531129775053684256071819837294436069133592772543582735985855506250660938574234958754211349215293281645205354069970790155237033436065434572020652955666855773232074749487007626050323967496732359278657193580493324467258802863, 4379499308310772821004090447650785095356643590411706358119239166662089428685562719233435615196994728767593223519226235062647670077854687031681041462632566890129595506430188602238753450337691441293042716909901692570971955078924699306873191983953501093343423248482960643055943413031768521782634679536276233318, 85256449776780591202928235662805033201684571648990042997557084658000067050672130152734911919581661523957075992761662315262685030115255938352540032297113615687815976039390537716707854569980516690246592112936796917504034711418465442893323439490171095447109457355598873230115172636184525449905022174536414781771, 50576597458517451578431293746926099486388286246142012476814190030935689430726042810458344828563913001012415702876199708216875020997112089693759638454900092580746638631062117961876611545851157613835724635005253792316142379239047654392970415343694657580353333217547079551304961116837545648785312490665576832987, 96868738830341112368094632337476840272563704408573054404213766500407517251810212494515862176356916912627172280446141202661640191237336568731069327906100896178776245311689857997012187599140875912026589672629935267844696976980890380730867520071059572350667913710344648377601017758188404474812654737363275994871, 4881261656846638800623549662943393234361061827128610120046315649707078244180313661063004390750821317096754282796876479695558644108492317407662131441224257537276274962372021273583478509416358764706098471849536036184924640593888902859441388472856822541452041181244337124767666161645827145408781917658423571721, 18237936726367556664171427575475596460727369368246286138804284742124256700367133250078608537129877968287885457417957868580553371999414227484737603688992620953200143688061024092623556471053006464123205133894607923801371986027458274343737860395496260538663183193877539815179246700525865152165600985105257601565]
# import math

# print("(a | p) = pow(a,(p-1)/2)%p ....")
# x = (p-1)//2
# y = (p+1)//4
# for a in ints:
#     #res = (pow(a,(p-1)/2)) % p
#     res = pow(a,x,p)
#     if res == 1:
#         print("it is a quadratic residue")
#         z = pow(a,y,p)
#         print(z)
#     elif res == p-1:
#         print("it is a non residue")
#     elif res == 0:
#         print("a = 0 (mod p)")
#     else:
#         print("something went wrong :(")

# print(ints[1] % p)

# def is_quadratic(x,p):
#     if x%p == 0:
#         return 1
#     return pow(x,(p-1)//2,p) == 1



####################################

# from Crypto.PublicKey import RSA

# f = open("privacy_enhanced_mail_1f696c053d76a78c2c531bb013a92d4a.pem",'r')
# key = RSA.importKey(f.read())

# print(key)

#####################################

# Tonellli Shanks


# a = 8479994658316772151941616510097127087554541274812435112009425778595495359700244470400642403747058566807127814165396640215844192327900454116257979487432016769329970767046735091249898678088061634796559556704959846424131820416048436501387617211770124292793308079214153179977624440438616958575058361193975686620046439877308339989295604537867493683872778843921771307305602776398786978353866231661453376056771972069776398999013769588936194859344941268223184197231368887060609212875507518936172060702209557124430477137421847130682601666968691651447236917018634902407704797328509461854842432015009878011354022108661461024768
# p = 30531851861994333252675935111487950694414332763909083514133769861350960895076504687261369815735742549428789138300843082086550059082835141454526618160634109969195486322015775943030060449557090064811940139431735209185996454739163555910726493597222646855506445602953689527405362207926990442391705014604777038685880527537489845359101552442292804398472642356609304810680731556542002301547846635101455995732584071355903010856718680732337369128498655255277003643669031694516851390505923416710601212618443109844041514942401969629158975457079026906304328749039997262960301209158175920051890620947063936347307238412281568760161

# def tonelli_shanks(x,p):
#     if x%p == 0:
#         return 0
    
#     if not is_quadratic(x,p):
#         print("This is not a quadratic residue")
#         return None
#     else :
#         print("This value of n is quadratic residue.")

#     if p%4 == 3:
#         return pow(x,(p+1)//4,p)
    
#     # for p =1 (mod 4)
#     # p-1 = Q* (2^S)
#     Q = p-1
#     S = 0
#     while Q%2 == 0:
#         S += 1
#         Q //= 2
#     print("Q = ",Q)
#     print("S = ",S)

#     # find a non - quadratic residue of p by brute force

#     z = 2
#     while is_quadratic(z,p):
#         z += 1
#     print("z=",z)

#     # intialise variables 
#     M = S
#     c = pow(z,Q,p)    
#     t = pow(x,Q,p)
#     R = pow(x, (Q+1)//2,p)


#     while t!= 1:
#         print("Loop")

#         # Calculate i
#         i = 0
#         temp = t 
#         while temp != 1:
#             i += 1
#             temp = (temp *temp) % p
#         print("i = ",i)   

#         # calculate b, M,c,t,R
#         pow2 = 2 ** (M-i-1)
#         b = pow(c,pow2,p)
#         M = i
#         c = (b*b)%p
#         t = (t*b*b)%p
#         R = (R*b) % p

#     return R,p-R      

# print(tonelli_shanks(a,p))

####################################

# Chinese Remainder Theorem
# rem = [2,3,5]
# num = [5,11,17]
# k = 0
# while(1):
#     if(((17*k + 5)%11 == 3) & ((17*k + 5)%5 == 2)):
#         break
#     k = k+1    
# print(17*k + 5)        

######################################

# RSA encryption is modular exponentiation of a message with an exponent e and a modulus N which is normally a product of two primes: N = p * q.
# RSA public Key 
# Together the exponent and modulus form an RSA "public key" (N, e)

'''
 Fun fact :Multiplicative Inverse Theorem
Let n
and x be positive integers. Then x has a multiplicative inverse modulo n if and only if gcd(n,x)=1. Moreover, if it exists, then the multiplicative inverse is unique. 
'''

# RSA Private Key
# RSA the private key is the modular multiplicative inverse of the exponent e modulo the totient of N.

# w = 857504083339712752489993810777
# q = 1029224947942998075080348647219

# N = w*q
# tot_N = (w-1)*(q-1)
# e = 65537
# print(pow(e,tot_N - 2,tot_N))
# # it doesn't give the right answer as tot_N is not prime number

# gcd,x,y = p_q(e,tot_N)
# print(x)
# # works always

# def foo(a,p):
#     # print(a)p
#     e = 2
#     while(pow(a,e,p) != a):
    
#     #    print(pow(a,e,p))
#        e = e+1
#     print(e) 
# a = int(input())
# p = int(input())

# foo(a,p)    
text = "63727970746f7b596f755f77696c6c5f62655f776f726b696e675f776974685f6865785f737472696e67735f615f6c6f747d"
print(bytes.fromhex(text))